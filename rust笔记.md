# 1.常见变成概念

## 1.1变量和可变性质

```rust
fn main() {
let x = 5;
println!("The value of x is: {x}");
x = 6;
println!("The value of x is: {x}");
}
//输出的变量内容需要用{}装起来，这就像卖出商品的包装一样
//使用mut明确的标识变量是否会被改变，这一点有利于推导代码。
//
```

### 1.1.1常量

类似不可变量，常量是绑定到一个名称的不允许改变的值。

值得注意的是：

1. 不允许对常量使用mut。

2. 常量不光默认不可改变，它总是不变。

3. 声明常量使用const关键字而不是let，并且必须注明值的类型。

4. 常量可以在任何作用域中声明，包括全局作用域。

5. 常量只能被设置为常量表达式，而不可以是任何其他只能在运行时计算出的值。

   ```RUST
   const THREE_HOURS_IN_SECONDS: U32 =60*60*60;
   ```

将结果写成一组有限的操作，目的是为了更好的理解和验证此值。

在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值。

### 1.1.2隐藏（shadowing）

我们可以定义一个与之前同名的新变量，这就是隐藏。隐藏与作用域这个概念紧密相关。

```rust
fn main(){
let x=5;
let x=x+1;
{
let x=x*2;
println!("{x}");
}
println!("{x}");
}
//第一个输出的结果为12，第二个输出的结果为6
```

隐藏与将变量标记为mut是由区别的。当不小心尝试对变量重新赋值 时，如果没有使用let关键字，就会导致编译时的错误。通过使用let，我们可以用这个值进行一些计算，不过计算之后变量仍然是不可变的。

使用隐藏的时候不能带上mut，因为此时无法改变变量的类型。

## 1.2数据类型

在rust中，每一个值都属于某一个数据类型（data type），这告诉rust它被指定为何种数据。以便明确数据处理方式。我们将看到两类数据类型子集：**标量**（scalar）和**复合**（compound）。

rust属于静态类型的语言，也就是说在编译的时就必须知道所有变量的类型。当多种类型均有可能的时候，必须添加类型注解：

```rust
let guess : u32 ="42".prase().expert("Not a number");
//prase()用于将string类型转换为数字，但是数字有不同的类型所以需要告诉编译器这个变量的类型。
```

### 1.2.1标量类型

标量类型代表一个单独的值。rust中有四种基本类型标量分别是：整数，浮点型，布尔类型，字符类型。

**整数**

整数是一个没有小数部分的数字。i32代表有符号的长度为32bit的数字，而u32代表没有符号的长度为32位的数字。

若是arch类型则是isize和usize，这两种类型依赖运行程序的计算机架构。

**浮点型**

分别是两种类型：f32-单精度浮点数和f64-多精度浮点数

所有的浮点型都是有符号的。

**数值运算**

包含加减乘除取余

**布尔型**

bool标识类型，true和false代表种类

**字符类型**

chat，rust的char类型的大小分为四个字节（four bytes）

### 1.2.2复合类型

复合类型一共存在两种类型分别是：元组（tuple）和数组（array）。

**元组类型**

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。

元组长度固定：一旦声明，其长度不会增大或者缩小。

例如：

```rust
let tup：（i32,f64,u8）=(500,6.4,1);
let (x,y,z)=tup;//解构操作
//也可以通过点号（.）后跟索引来直接访问他们。
tup.0；
元组的第一个索引值为0；
```

不带任何的元组有个特殊的名称，交租单元元组。

**数组类型**

数组包含的多个值类型必须相同。

rust中数组的长度是固定的。

```rust
let a:[i32;5]=[1,2,3,4,5];
let a=[3;5] //表示a数组中存在五个元素每个元素的值是5
```

交代元素类型和数目。

### 1.3函数

rust代码中的函数和变量名都是用snake case规范风格。

所有的字母都是小写并使用下划线分隔单词。rust不关心函数定义的位置，只要函数被调用时出现在调用之处可见的作用域就行。

### 1.3.1参数

我们可以定义拥有参数的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。参数需要明确表示类型

### 1.3.2语句

rust是一门基于表达式的语言。

**语句**是执行一些操作但不返回值的指令。表达式计算并产生一个值。

**表达式**

计算并产生一个值。

具体来说就是函数中不带分号的表达式可以作为返回值。

在rust中不能出现x=y=6的情况。而是使用代码块的返回值来作为赋值的对象，例如：

```rust
fn main() -> u32{
let y={
let x:u32=3;
x+1
};
}
```

在参数括号后面跟着返回值的类型。

### 1.4控制流

if**表达式**

判断条件的类型必须是bool。

if number {}这种写法在rust中成立的前提就是，number此时的类型必须是bool。

rust会用match来匹配多种情况。

**在let语句中使用if**

```rust
fn main(){
let condition =true;
let number =if condition{5}else{6};
println!("");
}
```

**使用循环重复执行**

第一个关键字：loop；

loop会一直执行代码段中的内容，此时需要break来跳出当前的动作。

```rust
'counting_up:loop{}
//通过循环标记可以让其通过break跳出到合适的位置。
```

**while**

只有当条件为真的时候才会执行，简单粗暴。

**for**

```rust
fn main(){
let a=[1,2,3,4,5];
for element in a
{
println!("{element}");
}
}
//如果需要操作每一个数组中的元素那么可以考虑使用这种用法

fn main()
{
    for number in (1..4).rev()
    {
        println!("{}");
    }
    println!("{}");
    
}
// .rev() 可以直接反转数组，好用的小技巧
```

# 2.所有权（ownership）

## 2.1什么是所有权

作为rust的核心功能之一，该概念对其他部分有着深刻的影响。

所有程序都必须管理其运行时使用的内存。