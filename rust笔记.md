# 1.常见变成概念

## 1.1变量和可变性质

```rust
fn main() {
let x = 5;
println!("The value of x is: {x}");
x = 6;
println!("The value of x is: {x}");
}
//输出的变量内容需要用{}装起来，这就像卖出商品的包装一样
//使用mut明确的标识变量是否会被改变，这一点有利于推导代码。
//
```

### 1.1.1常量

类似不可变量，常量是绑定到一个名称的不允许改变的值。

值得注意的是：

1. 不允许对常量使用mut。

2. 常量不光默认不可改变，它总是不变。

3. 声明常量使用const关键字而不是let，并且必须注明值的类型。

4. 常量可以在任何作用域中声明，包括全局作用域。

5. 常量只能被设置为常量表达式，而不可以是任何其他只能在运行时计算出的值。

   ```RUST
   const THREE_HOURS_IN_SECONDS: U32 =60*60*60;
   ```

将结果写成一组有限的操作，目的是为了更好的理解和验证此值。

在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值。

### 1.1.2隐藏（shadowing）

我们可以定义一个与之前同名的新变量，这就是隐藏。隐藏与作用域这个概念紧密相关。

```rust
fn main(){
let x=5;
let x=x+1;
{
let x=x*2;
println!("{x}");
}
println!("{x}");
}
//第一个输出的结果为12，第二个输出的结果为6
```

隐藏与将变量标记为mut是由区别的。当不小心尝试对变量重新赋值 时，如果没有使用let关键字，就会导致编译时的错误。通过使用let，我们可以用这个值进行一些计算，不过计算之后变量仍然是不可变的。

使用隐藏的时候不能带上mut，因为此时无法改变变量的类型。

## 1.2数据类型

在rust中，每一个值都属于某一个数据类型（data type），这告诉rust它被指定为何种数据。以便明确数据处理方式。我们将看到两类数据类型子集：**标量**（scalar）和**复合**（compound）。

rust属于静态类型的语言，也就是说在编译的时就必须知道所有变量的类型。当多种类型均有可能的时候，必须添加类型注解：

```rust
let guess : u32 ="42".prase().expert("Not a number");
//prase()用于将string类型转换为数字，但是数字有不同的类型所以需要告诉编译器这个变量的类型。
```

### 1.2.1标量类型

标量类型代表一个单独的值。rust中有四种基本类型标量分别是：整数，浮点型，布尔类型，字符类型。

**整数**

整数是一个没有小数部分的数字。i32代表有符号的长度为32bit的数字，而u32代表没有符号的长度为32位的数字。

若是arch类型则是isize和usize，这两种类型依赖运行程序的计算机架构。

**浮点型**

分别是两种类型：f32-单精度浮点数和f64-多精度浮点数

所有的浮点型都是有符号的。

**数值运算**

包含加减乘除取余

**布尔型**

bool标识类型，true和false代表种类

**字符类型**

chat，rust的char类型的大小分为四个字节（four bytes）

### 1.2.2复合类型

复合类型一共存在两种类型分别是：元组（tuple）和数组（array）。

**元组类型**

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。

元组长度固定：一旦声明，其长度不会增大或者缩小。

例如：

```rust
let tup：（i32,f64,u8）=(500,6.4,1);
let (x,y,z)=tup;//解构操作
//也可以通过点号（.）后跟索引来直接访问他们。
tup.0；
元组的第一个索引值为0；
```

不带任何的元组有个特殊的名称，交租单元元组。

**数组类型**

数组包含的多个值类型必须相同。

rust中数组的长度是固定的。

```rust
let a:[i32;5]=[1,2,3,4,5];
let a=[3;5] //表示a数组中存在五个元素每个元素的值是5
```

交代元素类型和数目。

### 1.3函数

rust代码中的函数和变量名都是用snake case规范风格。

所有的字母都是小写并使用下划线分隔单词。rust不关心函数定义的位置，只要函数被调用时出现在调用之处可见的作用域就行。

### 1.3.1参数

我们可以定义拥有参数的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。参数需要明确表示类型

### 1.3.2语句

rust是一门基于表达式的语言。

**语句**是执行一些操作但不返回值的指令。表达式计算并产生一个值。

**表达式**

计算并产生一个值。

具体来说就是函数中不带分号的表达式可以作为返回值。

在rust中不能出现x=y=6的情况。而是使用代码块的返回值来作为赋值的对象，例如：

```rust
fn main() -> u32{
let y={
let x:u32=3;
x+1
};
}
```

在参数括号后面跟着返回值的类型。

### 1.4控制流

if**表达式**

判断条件的类型必须是bool。

if number {}这种写法在rust中成立的前提就是，number此时的类型必须是bool。

rust会用match来匹配多种情况。

**在let语句中使用if**

```rust
fn main(){
let condition =true;
let number =if condition{5}else{6};
println!("");
}
```

**使用循环重复执行**

第一个关键字：loop；

loop会一直执行代码段中的内容，此时需要break来跳出当前的动作。

```rust
'counting_up:loop{}
//通过循环标记可以让其通过break跳出到合适的位置。
```

**while**

只有当条件为真的时候才会执行，简单粗暴。

**for**

```rust
fn main(){
let a=[1,2,3,4,5];
for element in a
{
println!("{element}");
}
}
//如果需要操作每一个数组中的元素那么可以考虑使用这种用法

fn main()
{
    for number in (1..4).rev()
    {
        println!("{}");
    }
    println!("{}");
    
}
// .rev() 可以直接反转数组，好用的小技巧
```

# 2.所有权（ownership）

## 2.1什么是所有权

作为rust的核心功能之一，该概念对其他部分有着深刻的影响。

所有程序都必须管理其运行时使用的内存的方式。一些语言中存在垃圾回收机制，在程序运行时规律的寻找不再使用的内存。另一些语言中程序员必须亲自分配和释放内存。rust则选择了第三种方式：通过所有权系统管理内存。编译器在编译的时会根据一系列的规则进行检查，如果违反这些规则，程序都不能把编译。

 所有权的主要目的就是为了**管理堆数据。**

### 2.1.1所有权规则

1. **每个值都有一个所有者（Owner）**：在 Rust 中，变量拥有其值的所有权。当拥有者（owner）超出作用域时，值就会被释放。
2. **一次只能有一个可变引用或多个不可变引用**：这个规则确保在同一时间内，要么有一个可变引用（mutable reference），要么有多个不可变引用（immutable references），但不能同时拥有可变引用和不可变引用。这样的规则保证了线程安全，防止了数据竞争。
3. **所有权可以通过移动转移**：当将拥有某个值的变量赋值给另一个变量时，所有权会从一个变量移动到另一个变量。这意味着源变量将不再有效，防止了悬空引用。
4. **所有权可以通过借用（borrowing）来共享**：通过引用（references），可以在不转移所有权的情况下让多个部分访问同一份数据。
5. **所有权规则适用于所有类型**：所有权规则适用于所有类型，包括自定义类型和标准库类型。

### 2.1.2变量作用域

一个变量和其有效的作用域

1. 当变量进入作用域时，它就是有效的。
2. 这一直持续到它离开作用域为止。

### 2.1.3 String类型

```rust
fn main()
{
    let mut s = String::from("hello");
    s.push_str(", world");
    println!("{s}");
}
```

当S离开作用域后方，rust会调用一个特殊的函数名字为drop，用于释放s的内存。

### 2.1.4变量与数据交互的方式

1. **移动**

   ```rust
   fn main()
   {
       let x=5;
       let y=x;
   }
   //因为整数是已知固定大小的简单值，所以这两个5都被放入了栈中
   //但是当数据类型换成String的时候这个情况就不同了
   
   fn main()
   {
       let s1=String::("hello");
       let s2=s1;
   }
   //string在底层包含三部分，第一个部分是一个指针，指针的值就是string的内容，第二部分就是string的实际长度，使用了多少内存，而第三部分就是string从分配器获取了多少内存。
   //而当你使用上述赋值的情况时，会出现两种情况，第一种指针指向的value不复制，也就是说此时的s1，s2共享同一个内容，在此种情况下会出现重复释放的问题。那第二种情况就是value也赋值一份，但是这种情况就会非常影响性能。
   //因此，rust就做出了一个设定，当上述代码执行后，Rust认为s1不再有效，因此当s1离开作用域后不需要清理任何东西。
   //这里涉及一个rust的设计选择，Rust永远也不会自动创建数据的深拷贝，因此任何自动的复制都可以被认为是对运行时性能影响较小的。
   ```

   

2. 克隆

   当我们确实需要深度复制string中堆上的数据，而不仅仅是栈上的数据，我们可以使用一个**clone**的通用函数。

   

   

   